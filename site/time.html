<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8"><!-- Устанавливает кодировку документа в UTF-8, поддерживает кириллицу -->
  <title>Новое время</title><!-- Заголовок вкладки браузера -->
  <style>
    /* Сбрасываем отступы у html/body, растягиваем фон на весь экран, центруем canvas */
    html, body {
      margin: 0;               /* Убираем внешние отступы */
      padding: 0;              /* Убираем внутренние отступы */
      width: 100%;             /* Ширина на все 100% окна */
      height: 100%;            /* Высота на все 100% окна */
      background: #fff;        /* Серый фон позади часов #f0f0f0;*/
      display: flex;           /* Флекс-контейнер для центрирования */
      justify-content: center; /* Центрируем по горизонтали */
      align-items: center;     /* Центрируем по вертикали */
    }
    /* Оформление самого <canvas> под часы */
    canvas {
      background: #fff;                    /* Белый фон циферблата */
      /*  box-shadow: 0 0 20px rgba(0,0,0,0.3); */  /* Лёгкая тень вокруг */
      /* Будем растягивать канвас с сохранением пропорций */
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
    }
  </style>
</head>
<body>
  <!-- Холст, на котором рисуем часы -->
  <canvas id="clock"></canvas>

  <script>
    // Получаем элемент canvas и его 2D-контекст для рисования
    const canvas = document.getElementById('clock');
    const ctx    = canvas.getContext('2d');

    // Значения, которые будут пересчитываться при изменении размеров окна
    let W, H, Cx, Cy, R;

    // Функция подстройки размеров canvas под окно
    function resizeCanvas() {
      // Берём минимальную сторону окна, чтобы сохранить круг, не обрезая его
      const size = Math.min(window.innerWidth, window.innerHeight);
      canvas.width  = size;
      canvas.height = size;
      // Пересчитываем параметры холста
      W  = canvas.width;
      H  = canvas.height;
      Cx = W / 2;
      Cy = H / 2;
      R  = W / 2 * 0.9; // радиус — 90% от половины стороны
    }

    // Инициалальная подстройка
    resizeCanvas();
    // Подстройка при каждом изменении размеров окна
    window.addEventListener('resize', resizeCanvas);

    /**
     * Функция drawFace(): рисует статическую часть часов —
     * круг, засечки, цифры 0…9 и маленькие нули рядом с большими цифрами
     */
    function drawFace() {
      // Очищаем предыдущий кадр целиком
      ctx.clearRect(0, 0, W, H);

      // 1) Рисуем главный круг циферблата
      ctx.beginPath();
      ctx.arc(Cx, Cy, R, 0, 2 * Math.PI);
      ctx.fillStyle   = '#fff';
      ctx.fill();
      ctx.lineWidth   = 12 * (W / 800);  // масштабируем толщину рамки
      ctx.strokeStyle = '#333';
      ctx.stroke();

      // 2) Рисуем 100 небольших точек-засечек
      ctx.fillStyle = '#333';
      for (let i = 0; i < 100; i++) {
        const angle = i / 100 * 2 * Math.PI - Math.PI / 2;
        const dist  = R * 0.95;
        const x = Cx + Math.cos(angle) * dist;
        const y = Cy + Math.sin(angle) * dist;
        ctx.beginPath();
        ctx.arc(x, y, 3 * (W / 800), 0, 2 * Math.PI);
        ctx.fill();
      }

      // 3) Рисуем 10 крупных меток, цифры 0…9, и рядом маленькие нули
      const bigFontSize = R * 0.12;        // размер шрифта для больших цифр
      ctx.font         = `${bigFontSize}px sans-serif`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';

      for (let i = 0; i < 10; i++) {
        const angle = i / 10 * 2 * Math.PI - Math.PI / 2;

        // 3.1) Линия-метка
        const x1 = Cx + Math.cos(angle) * R * 0.9;
        const y1 = Cy + Math.sin(angle) * R * 0.9;
        const x2 = Cx + Math.cos(angle) * R;
        const y2 = Cy + Math.sin(angle) * R;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineWidth   = 6 * (W / 800);
        ctx.strokeStyle = '#333';
        ctx.stroke();

        // 3.2) Большая цифра
        const tx = Cx + Math.cos(angle) * R * 0.78;
        const ty = Cy + Math.sin(angle) * R * 0.78;
        ctx.fillStyle = '#000';
        ctx.fillText(i.toString(), tx, ty);

        // 3.3) Маленький «0» рядом
        // Сохраняем предыдущие настройки
        const oldFont      = ctx.font;
        const oldAlign     = ctx.textAlign;
        const oldBaseline  = ctx.textBaseline;

        const smallFontSize = R * 0.06;    // размер шрифта для «0»
        ctx.font            = `${smallFontSize}px sans-serif`;
        ctx.textAlign       = 'left';      // рисуем вправо от точки
        ctx.textBaseline    = 'bottom';    // базовая линия — низ символа

        // Вычисляем позицию «0»:
        // по X — вправо от центра большой цифры на 5% R
        // по Y — на нижнюю границу большой цифры:
        // bigFontSize/2 — половина высоты большого шрифта
        const zeroX = tx + R * 0.04;
        const zeroY = ty + (bigFontSize / 2.5);

        ctx.fillText('0', zeroX, zeroY);

        // Восстанавливаем шрифты и выравнивание
        ctx.font         = oldFont;
        ctx.textAlign    = oldAlign;
        ctx.textBaseline = oldBaseline;
      }
    }

    /**
     * Функция drawHand(): рисует одну стрелку часов
     * angle  — угол (в радианах), куда направлена стрелка
     * length — длина стрелки в долях от R
     * width  — толщина стрелки в px
     * color  — цвет стрелки
     */
    function drawHand(angle, length, width, color) {
      const a = angle - Math.PI / 2; // сдвиг, чтобы 0-рadian была вверх
      const x = Cx + Math.cos(a) * R * length;
      const y = Cy + Math.sin(a) * R * length;
      ctx.beginPath();
      ctx.moveTo(Cx, Cy);
      ctx.lineTo(x, y);
      ctx.lineWidth   = width * (W / 800);
      ctx.strokeStyle = color;
      ctx.lineCap     = 'round';
      ctx.stroke();
    }

    /**
     * Функция drawTime(): вычисляет «десятичное» время
     * и рисует три стрелки
     */
    function drawTime() {
      const now = new Date();
      // обычные секунды сегодня
      const ordinarySec =
        now.getHours()   * 3600 +
        now.getMinutes() * 60 +
        now.getSeconds() +
        now.getMilliseconds() / 1000;
      // переводим в десятичные секунды
      const decTotalSec = ordinarySec * 100000 / 86400;
      // h (0…9), m (0…99), s (0…100)
      const h = Math.floor(decTotalSec / 10000);
      const m = Math.floor((decTotalSec % 10000) / 100);
      const s = decTotalSec % 100;
      // вычисляем углы для стрелок
      const angleH = (h + m/100 + s/10000) / 10  * 2 * Math.PI;
      const angleM = (m + s/100)      / 100 * 2 * Math.PI;
      const angleS = s               / 100 * 2 * Math.PI;
      // рисуем стрелки
      drawHand(angleH, 0.4, 18, '#000');     // часовая
      drawHand(angleM, 0.7, 10, '#007ACC');  // минутная
      drawHand(angleS, 0.9, 6,  '#CC0000');  // секундная
      // центральная точка
      ctx.beginPath();
      ctx.arc(Cx, Cy, 13 * (W / 800), 0, 2*Math.PI);
      ctx.fillStyle = '#333';
      ctx.fill();
    }

    /**
     * Анимационный цикл: перерисовывает всё ~60 раз/с
     */
    function animate() {
      drawFace();
      drawTime();
      requestAnimationFrame(animate);
    }

    // Стартуем
    animate();
  </script>
</body>
</html>
